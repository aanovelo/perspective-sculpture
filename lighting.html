<!DOCTYPE html>
<html>

<head>
  <script type="x-shader/x-vertex" id="vshader">
      attribute vec4 aPosition;
      attribute vec4 aNormal;   //variable for normal vector at each vertex

      uniform mat4 uModelMatrix;                //Model Matrix
      uniform mat4 uViewMatrix;                 //View Matrix
      uniform mat4 uProjectionMatrix;           //Projection Matrix

      uniform mat4 uNormalMatrix;               //Normal Matrix
      
      uniform vec4 uMaterialDiffuseColor;       //Kd
      uniform vec4 uLightDiffuseColor;          //Ld

      uniform vec4 uLightDirectionVector;       //l

      varying vec4 vDiffuseColor;

      void main() {

        gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;

        //get Corrected Normal vector from transformation
        vec4 corrected_aNormal = uNormalMatrix * aNormal;

        //get normalized normal and light vector
            vec4 normalized_aNormalVector = normalize(corrected_aNormal);
            vec4 normalized_uLightDirectionVector = normalize(uLightDirectionVector);

        //get lambertCooeficient = (-l . n)
            float lambertCoefficient = max(dot(-normalized_uLightDirectionVector,normalized_aNormalVector),0.0);

        //Fd = Ld * Kd * (n dot -l)
            vec4 diffuseColor =  uMaterialDiffuseColor * uLightDiffuseColor * lambertCoefficient;

        vDiffuseColor = vec4(diffuseColor.r, diffuseColor.g, diffuseColor.b, 1.0);
      }
    </script>

  <script type="x-shader/x-fragment" id="fshader">
      precision mediump float;


      varying vec4 vDiffuseColor;
      void main() {
        gl_FragColor = vDiffuseColor;
      }
    </script>

  <!--Import external javascript file-->
  <!--Helper javascript methods for initializing webgl-->
  <script src="./lib/webgl-init.js"></script>
  <script src="./lib/webgl-utils.js"></script>
  <script src="./lib/webgl-debug.js"></script>
  <script src="./lib/gl-matrix-min.js"></script>


  <script>

    function main() {
      //Retrieve <canvas> element
      var canvas = document.getElementById("main_canvas");
      if (!canvas) {
        console.log("Failed to retrieve the <canvas> element");
      }

      //Get the rendering context (WebGL)
      var gl = initializeWebGL(canvas, true);
      //initialize shaders program
      var vertexShader = initializeShader(gl, "vshader");
      var fragmentShader = initializeShader(gl, "fshader");
      var program = initializeProgram(gl, vertexShader, fragmentShader);
      gl.useProgram(program);

      var aPositionPointer = gl.getAttribLocation(program, "aPosition");
      gl.enableVertexAttribArray(aPositionPointer);
      var aNormalPointer = gl.getAttribLocation(program, "aNormal");
      gl.enableVertexAttribArray(aNormalPointer);

      var uFragColorPointer = gl.getUniformLocation(program, "uColor");
      var uModelMatrixPointer = gl.getUniformLocation(program, "uModelMatrix");
      var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
      var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);


      //ENABLE DEPTH TESTING
      gl.enable(gl.DEPTH_TEST);
      gl.clear(gl.DEPTH_BUFFER_BIT);

      var modelMatrix;
      var viewMatrix;
      var projectionMatrix;

      /**START PROJECTION MATRIX SPECIFICATION**/
      var fieldOfViewYAxis = glMatrix.toRadian(30);
      var aspectRatio = canvas.width / canvas.height;
      var left = -20;
      var right = 20;
      var bottom = -20;
      var top = 20;
      var nearPlane = 1;
      var farPlane = 100;

      projectionMatrix = mat4.create();
      mat4.ortho(projectionMatrix, left, right, bottom, top, nearPlane, farPlane);
      gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));
      /**END PROJECTION MATRIX SPECIFICATION**/

      /**START VIEW MATRIX SPECIFICATION**/
      var lookAtX = Math.random() * 5; // random point where the camera is looking at
      var lookAtY = Math.random() * 10; 
      var lookAtZ = Math.random() * 10; 
      var lookAtPoint = [lookAtX, lookAtY, lookAtZ, 1.0]; // where the camera is looking at
      var eyePoint = [0.0, 0.0, 10.0, 1.0];   // where the camera is placed
      var upVector = [0.0, 1.0, 0.0, 0.0];    // orientation of the camera

      viewMatrix = mat4.create();
      mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);
      gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));
      /**END VIEW MATRIX SPECIFICATION**/

      //MODEL MATRIX
      modelMatrix = mat4.create();
      modelMatrix = mat4.identity(modelMatrix);
      gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(modelMatrix));

      //add normal matrix
      var normalMatrix = mat4.create();
      var uNormalMatrixPtr = gl.getUniformLocation(program, "uNormalMatrix");
      mat4.invert(normalMatrix, modelMatrix);
      mat4.transpose(normalMatrix, normalMatrix);
      gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(normalMatrix));

      //set-up light and material parameters
      var uMaterialDiffuseColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
      gl.uniform4f(uMaterialDiffuseColorPtr, 0.0, 1.0, 0.0, 1.0);

      var uLightDiffuseColorPtr = gl.getUniformLocation(program, "uLightDiffuseColor");
      gl.uniform4f(uLightDiffuseColorPtr, 1.0, 1.0, 1.0, 1.0);

      var uLightDirectionVectorPtr = gl.getUniformLocation(program, "uLightDirectionVector");
      gl.uniform4f(uLightDirectionVectorPtr, -1.0, -3.0, -5.0, 0.0);

      // Initialize the cube parameters and dimensions
      var cubeCountLength = 10;
      var cubeCountHeight = 5;
      var cubeCount = cubeCountLength * cubeCountHeight;
      var edgeLength = 2.0;
      var startCoordX = -cubeCountLength * edgeLength / 2;
      var startCoordY = 0;
      var generatedCubes = [];

      // Create the cubes
      function createCubes() {
        for (var i = 0; i < cubeCountLength; i++) {
          for (var j = 0; j < cubeCountHeight; j++) {
            var x = startCoordX + i * edgeLength;
            var y = startCoordY + j * edgeLength;
            var z = Math.random() * -50;
            var cube = [
              // Front face
              x - 1.0, y - 1.0, z + 1.0, 1.0,
              x + 1.0, y - 1.0, z + 1.0, 1.0,
              x + 1.0, y + 1.0, z + 1.0, 1.0,
              x - 1.0, y + 1.0, z + 1.0, 1.0,

              // Back face
              x - 1.0, y - 1.0, z - 1.0, 1.0,
              x - 1.0, y + 1.0, z - 1.0, 1.0,
              x + 1.0, y + 1.0, z - 1.0, 1.0,
              x + 1.0, y - 1.0, z - 1.0, 1.0,

              // Top face
              x - 1.0, y + 1.0, z - 1.0, 1.0,
              x - 1.0, y + 1.0, z + 1.0, 1.0,
              x + 1.0, y + 1.0, z + 1.0, 1.0,
              x + 1.0, y + 1.0, z - 1.0, 1.0,

              // Bottom face
              x - 1.0, y - 1.0, z - 1.0, 1.0,
              x + 1.0, y - 1.0, z - 1.0, 1.0,
              x + 1.0, y - 1.0, z + 1.0, 1.0,
              x - 1.0, y - 1.0, z + 1.0, 1.0,

              // Right face
              x + 1.0, y - 1.0, z - 1.0, 1.0,
              x + 1.0, y + 1.0, z - 1.0, 1.0,
              x + 1.0, y + 1.0, z + 1.0, 1.0,
              x + 1.0, y - 1.0, z + 1.0, 1.0,

              // Left face
              x - 1.0, y - 1.0, z - 1.0, 1.0,
              x - 1.0, y - 1.0, z + 1.0, 1.0,
              x - 1.0, y + 1.0, z + 1.0, 1.0,
              x - 1.0, y + 1.0, z - 1.0, 1.0
            ];
            generatedCubes.push(cube);
          }
        }
      }
      createCubes();

      // Indices of the vertices
      var indices = [
        0, 1, 2, 0, 2, 3,    // Front face
        4, 5, 6, 4, 6, 7,    // Back face
        8, 9, 10, 8, 10, 11,  // Top face
        12, 13, 14, 12, 14, 15, // Bottom face
        16, 17, 18, 16, 18, 19, // Right face
        20, 21, 22, 20, 22, 23  // Left face
      ];

      //buffer creation
      var indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

      var normals = [   // Normal of each vertex
        0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,   // front
        0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0,  // front
        0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,   // front
        0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0,  // front
        1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,   // right
        -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0   // left
      ];
      //buffer creation
      var normalBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
      gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aNormalPointer);

      // Initialize the string parameters
      var generatedStrings = [];
      var cubeCenter = edgeLength / 2; 

      // Create the strings
      function createStrings(){
        for (var i = 0; i < cubeCount; i++) {
          var x = generatedCubes[i][0] + cubeCenter; // center of the cube
          var y = generatedCubes[i][1] + cubeCenter; // center of the cube
          var z = generatedCubes[i][2] - cubeCenter; // center of the cube
          var string = [
            x, y, z, 1.0,
            x, top, z, 1.0
          ];
          generatedStrings.push(string);
        }
      }
      createStrings();

      // cube buffer creation
      var cubeBuffer = gl.createBuffer();
      function drawCubes(cubeBuffer, cube) {
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube), gl.STATIC_DRAW);
        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(aPositionPointer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
      }

      // string buffer creation
      var stringBuffer = gl.createBuffer();
      function drawStrings(stringBuffer, string) {
        gl.bindBuffer(gl.ARRAY_BUFFER, stringBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(string), gl.STATIC_DRAW);
        gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(aPositionPointer);
        gl.drawArrays(gl.LINES, 0, 2); // Draw the line
      }

      // draw the cubes and strings
      for (var i = 0; i < cubeCount; i++) {
        drawCubes(cubeBuffer, generatedCubes[i]);
        drawStrings(stringBuffer, generatedStrings[i]);
      }


      // CANVAS ROTATION HANDLER
      // left click to rotate

      // how far the cam is from the object 
      const radius = 50.0;
      const easeFactor = 0.05;

      let isMouseDown = false;

      let cursorX = 0;
      let cursorY = 0;
      let currentCursorX = 0;
      let currentCursorY = 0;
      let initialMouseX = 0;
      let initialMouseY = 0;

      // Listen for mouse movement
      window.addEventListener('mousemove', (event) => {
        if (isMouseDown) {
          const mouseX = event.clientX;
          const mouseY = event.clientY;

          const deltaX = mouseX - initialMouseX;
          const deltaY = mouseY - initialMouseY;

          const sensitivity = 0.005;
          cursorX += deltaX * sensitivity;
          cursorY += deltaY * sensitivity;

          initialMouseX = mouseX;
          initialMouseY = mouseY;
        }
      });

      window.addEventListener('mousedown', (event) => {
        if (event.button === 0) {
          isMouseDown = true;
          initialMouseX = event.clientX;
          initialMouseY = event.clientY;
        }
      });

      window.addEventListener('mouseup', (event) => {
        if (event.button === 0) { // Left mouse button (button 0)
          isMouseDown = false;
        }
      });

      // Linear interpolation
      function interpolate(start, end, t) {
        return start + (end - start) * t;
      }

      function animate() {
        // interpolation
        currentCursorX = interpolate(currentCursorX, cursorX, easeFactor);
        currentCursorY = interpolate(currentCursorY, cursorY, easeFactor);

        // cursorY stays within limits
        const maxVerticalAngle = Math.PI / 2 - 0.01; // vertical rotation cannot go above 90 degrees
        const clampedCursorY = Math.max(Math.min(currentCursorY, maxVerticalAngle), -maxVerticalAngle);

        const eyeX = radius * Math.sin(currentCursorX) * Math.cos(clampedCursorY); // y axis rotation
        const eyeY = radius * Math.sin(clampedCursorY); // x axis rotation
        const eyeZ = radius * Math.cos(currentCursorX) * Math.cos(clampedCursorY); // y axis rotation
        const eyePoint = [eyeX, eyeY, eyeZ, 1.0];

        const viewMatrix = mat4.create();
        mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);

        gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix))

        // draw cubes weeeeeeeeeeeeeeeeeeeeeeeeee
        // todo: [cube1,cube2,...].foreach(drawCubes(stuff))
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        for (var i = 0; i < cubeCount; i++) {
          drawCubes(cubeBuffer, generatedCubes[i]);
          drawStrings(stringBuffer, generatedStrings[i]);
        }
        requestAnimationFrame(animate);
      }

      // start animation
      requestAnimationFrame(animate);
    }
  </script>
</head>

<body onload="main()" style="margin: 0;">
  <canvas id="main_canvas" width="800" height="800" style="border: 1px black solid; width: -webkit-fill-available;">
  </canvas>
</body>

</html>